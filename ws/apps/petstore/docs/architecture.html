<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>architecture</title>
</head>
<body>
<h2>Petstore 2.0 Architecture</h2>
<br>
In this chapter, we illustrate how the design and implementation of the pet 
store application. We explain the motivational factors and issues that need to 
be considered, and make these issues concrete by showing how we came to the 
decisions we eventually made as we architected the pet store application. 
Through this examination, we hope to make it easier for you to determine how 
best to architect and design your own Web service applications.<br>
<br>
<h3>Overview of PetStore and UseCases</h3>
<br>
PetStore provides the users the ability to upload their pets to the site, and to 
navigate it in a Web 2.0 fashion. The following diagram presents all the 
use-cases that are covered in the petstore.
<br>
&nbsp;<br>
<img alt="Use Case Diagram" longdesc="Use Cases for Pet Store" src="UseCaseDiagram1.png" width="878" height="743"><br>
<h2>High Level Architecture</h2>
<p>The following diagram shows the high level architecture for the petstore 
application</p>
<p>
<img alt="overall architecture" src="architecture.jpg" width="1051" height="983"></p>
<p>A number of factors were considered when designing the petstore application. 
Some of the key design considerations will now be outlined briefly: </p>
<ul>
	<li>Choice of tiers</li>
	<li>Using AJAX UI</li>
	<li>Data Access and Transactional Needs</li>
	<li>Page Application Architecture</li>
	<li>Security</li>
</ul>
<h3>Choice of Tiers</h3>
We chose to make it a pure web application. This means that we did not use the 
EJB technology to create reusable components.<br>
<h3>Using Ajax UI</h3>
Used an Ajax UI so used Dojo and custom JS. Plus decided to create a set of JSF 
components.<br>

<p>Ajax UI features: </p>

<p>When you mouse-over a link to each pet in the master list of query
results, you get a pop-up box that has the details information. This
pop-up uses an Ajax request to retrieve the data from the server.
This pop-up functionality is implemented as a JSF component and is
delivered as a part of the BluePrints Solutions catalog.</p>

<h3>Data Access and Transactional Needs</h3>

We used Java Persistence APIs to create an object relational mapping. We also 
created a facade that provides convenient access to access these OR POJOs and 
enforces transactional boundaries. .
<br>
<h3>Patterns to structure application</h3>
The petstore uses the Model-View-Controller (MVC) architectural pattern for 
overall structure. The controller is split in two: Web Controller and Ajax 
Controller.
<br>
The Web Controller keeps a mapping of client-requested URLs to action classes. 
It uses this mapping to invoke
<br>
<h3>Page Application Architecture</h3>
We grouped the functionality logically into pieces that belong on the same page. 
For example, all of the catalog browsing is done through a single page. Search 
is another page. User file upload is done through another page.
<br>
<h3>Using a JSF Component Library</h3>
<p>We chose to wrap most of the functionality in reusable JSF components. The 
JSF component library is written with JSF 1.2 version. </p>
<h3>Security</h3>
security considerations were like any classic web app, plus had to deal
with JS security model, masup with other services, user uploaded content. Our 
goal was to create a permissive system with security on need basis. The petstore 
application does not require a user to maintain an account or login to access 
functionality. However, we do use CAPTCHA to prevent automated systems from 
spamming the site. We also built a user-policing feature where users can mark 
some content as inappropriate, and it gets removed.<br>


<br>
<h3>Split Controller Architecture</h3>
We use two controllers: 
<br>
<ul>
<li>Client controller </li>
<li>Web controller</li>
</ul>

<p>The client controller is written in JavaScript and runs inside the browser of 
the user. The Web controller is written as a servlet. </p>
<p>The client-controller manages the UI presented to the user, and sends 
requests to the Web controller for getting data. </p>
<p>The Web controller uses action classes mapped to various request URLs to 
handle requests sent by the client controller. </p>

<h3>Communication between Browser and Server</h3>
<p>This communication is done in JSON. </p>


<h3>Mashups</h3>
Three styles of mashup were used in PS. Proxy, service delegation, and client library<br>
<h4>Proxy</h4>
This mashup
<h4>Service Delegation</h4>
This mashup
<h4>Client Library</h4>
This mashup
<br>
<h3>Tagging</h3>
<p>Tagging is implemented using the Lucene search engine.</p>

<p>The "Add Tags" functionality uses a hidden form to capture the tag
data.  When the "Add Tags" button is clicked the form is made visable
for the user to enter their tags.  Once the "Save" button is clicked,
an Ajax request is sent to the server with the added tag string.  The
response to the request will update the tag data field that is
currently displayed to the user.  If other users added a tag to the
same item, the other users tags would also be displayed.  This
methodology of re-synchronizing the data helps prevent situations
where the client data becomes out of sync with the server data when
the same item is edited by different users.</p>

<p>The tag page shows the top tags based on the number of items that
reference the tag.  CSS styles are used to change the font and color
of the tag also based on the number of references.  When a tag is
clicked, an Ajax call in executed to retrieve the items that are
reference by the tag and then displayed.  This page also has the popup
feature and a hyper-link in the name of the item that will forward the
user to the specific item on the catalog page, showing its detail.</p>

<h3>Search</h3>
<h4>Location based Search</h4>
<p>This is implemented by using Google Maps API. Present implementation details.</p>
<h4>Keyword Search</h4>
<p>This is implemented by using Apache Lucene search engine. Present 
implementation details. </p>

<p>In the petstore we used the Apache Lucence search engine to store
our indexes.  The name, description and tags are stored in the index
and can be searched on.  If the user only wants to search on the name
and the description and not the tags, then the "Also Search Tags"
checkbox can be unclicked.  All the information that is contained in
the indexes are also stored in the database, so if a corruption
occurs, the indexes can be regenerated.  Using the Lucene search
engine gives the Petstore a faster response to queries and also
supports advance search engine syntax which we would have to have
coded if we only use a database search methodology. </p>

<h3>Design of the Captcha</h3>

<p>The Captchas validation was implemented utilizing a servlet filter.
The CaptchaValidateFilter checks the uploaded Captchas value that is
sent in a cookie (so the multi-part mime stream of the upload doesn't
have to be touched) and validates it against a corresponding string
that is set in the session when the Seller upload page is rendered.
If the case insensitive values matches, then the upload proceeds.  If
not, then a status object is set with the error so it can be read by
the client and shown to the user, then the upload is discontinued.</p> 

<h3>Design of the Map Viewer</h3>

<p>The Main Map page is another front-end map page that utilizes the
database through the Java Persistence APIs to retrieve catalog items
by category.  This page leads into the Google Maps client-side mashup
page and displays the catalog items on the map for the selected
category.  By entering an optional center-point address with a search
area (in miles), the user can further restrict the category to show
only the items in the specific area around the center point. 
</p>

<h3>Design of the Client Controller</h3>
<p>The client controller is implemented with JavaScript and uses the Dojo 
toolkit library. It uses dojo.io.bind for making all the Ajax calls. </p>
<p>The client controller generates action events that are then handled by 
handlers. </p>
<p>The client controller also provides hooks (action handlers) to apply business 
logic, or GUI logic</p>
<p>The model data is cached on the client-side</p>
<p>We use View List Handler pattern to iterate over a large list of model data. </p>
<p>&nbsp;</p>
<h3>Design of the Web Controller</h3>

<p>The controller is implemented as a set of action classes each of which 
implements the ControllerAction interface. </p>
<p>
<img alt="ControllerAction interface and Action classes" src="controller-action.jpg" width="1038" height="242"></p>

<p>The ControllerServlet creates a mapping of these action classes with 
different request URIs, and then invokes actions based on the incoming request 
URI.</p>
<p>&nbsp;Controller Action classes are used to apply business logic for the incoming 
requests.&nbsp; </p>
<h3>Design of the Model Tier</h3>
Used Java Persistence APIs to build the model. 
<p>Object relational layer using Java Persistence API</p>

<br>
Used JTA. <br>
<h4>Model Facade</h4>
Used Facade pattern to:
<ul>
<li>Encapsulate underlying model data</li>
<li>Provide simple persistence operations</li>
<li>Hides the implementation details of using an object relational layer. </li>
<li>Provides transactional access</li>
</ul>
<br>
One model class per table. <br>
Model classes validate data before it is saved in the database.

</body>
</html>
